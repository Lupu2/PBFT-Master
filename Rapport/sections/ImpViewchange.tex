\subsection{View-change Implementation}
As previously mentioned in \autoref{sec:view-change} the goal of a view-change is to replace a faulty primary replica with another non-faulty replica successfully. In order for a view-change to be successful, the replicas in the \ac{pbft} network must agree upon a  protocol state that each replica can move on from after the leader change has occurred. Furthermore, the view-change must ensure that the newly selected primary replica is not also faulty. The implementation of the view-change functionality is a lot more complex in comparison to the normal protocol workflow. Several aspects make the view-change functionality challenging to handle appropriately. The view-change must first have some functionality to stop the regular protocol workflow, even when the protocol is still processing a request. Afterwards the view-change messages are exchanged over the \ac{pbft} network until $2f+1$ replicas agree that the system needs to change view. Finally, the replicas have to reprocess any protocol certificates saved in the protocol logger. Our implementation of the view-change can be better described by dividing the workflow into three segments. The first part consists of starting the view-change process. This includes the functionality for stopping active protocol instances. In this section, the application is also set to ignore future protocol messages received during the view-change process. The second part consists of updating the replica's view information and creating and multicasting a view-change message to the \ac{pbft} network. The second part is also responsible for creating the view-change certificate. The last segment is the functionality in regards to setting up the correct protocol state of the \ac{pbft} network for the new view.
We will in the following sections describe the different parts of our view-change implementation in the order in which they are performed.

\iffalse
As previously mentioned in \autoref{sec:view-change} the goal of a view-change is to successfully replace a faulty primary replica with another non-faulty replica. In order for a primary change to be successful, the replicas in the \ac{pbft} network must agree upon a  protocol state that each replica can move on from after the leader change has occurred. Furthermore, the view-change must ensure that the newly selected primary replica is not also faulty. The implementation of the view-change functionality is a lot more complex in comparison to the normal protocol workflow. There are several aspects that make the view-change functionality challenging to handle properly. The view-change must first have some functionality to stop the regular protocol workflow, even in the case where the protocol is still processing a request. Afterwards the view-change messages are exchanged over the \ac{pbft} network until $2f+1$ replicas agree that the system needs to change view. Finally the replicas have to reprocess any protocol certificates saved in the protocol logger. Our implementation of the view-change can be divided into three segments. The first part consists of starting the view-change process and how we set the application to stop and ignore future protocol messages received during the view-change process. The second part consists of updating the replica's view information and creating and multicasting a view-change message to the \ac{pbft} network. The second part is also responsible for creating the view-change certificate. The last segment is the functionality in regards to setting up the correct protocol state of the \ac{pbft} network for the new view.
We will in the following sections describe the different sections of our view-change implementation in the order in which they are performed.
\fi

\subsubsection{Starting a View-Change}
%insert how to start a view-change. Including timeout, setting application to inactive mode and how view-changes can be started by timeout vs protocol messages.
A View-change is started whenever a replica deems the current primary to be faulty. In our implementation, a replica can determine that a primary is defective in two separate ways. The first is the more common approach. We use a timeout functionality to detect irregular activity for the primary replica. The other condition that can start a view-change for the replica is when the replica has received a total of $2f$ view-changes messages from the other replicas in the \ac{pbft} network. In this situation, the replica knows that the view-change exchange only needs its own view-change message for it to be successful. 

In our case, we only support timeout functionality in the protocol workflow during the period where a replica is waiting for a pre-prepare phase message from the primary for a request the replica previously has received. \autoref{code:timeout} shows the source code for where the timeout functionality is initialized. \autoref{code:timeout} also shows how we initialize and how we stop the overall protocol workflow. On line 9-12 we can initialize the \code{AppOperation} within a \code{WhenAny} asynchronous function. The \code{WhenAny} creates a \code{CTask} for the two asynchronous \code{CTask} operations \code{AppOperation} and \code{ListenForShutdown}. The \code{CTask} created for \code{WhenAny} finishes whenever either of the \code{CTask} has finished its operation. In our case the \code{ListenForShutdown} is simply waiting for the given \code{Source} object \code{ShutdownSubject} to receive an item which constitutes as a shutdown signal. When a timeout occurs for the protocol workflow, the timeout emits an item to the \code{ShutdownSubject}, which in turn results in \code{ListenForShutdown} finishes first. Each iteration of the protocol workflow is given a \code{CancellationToken} to stop the timeout functionality after it has received a pre-prepare message from the primary. The \code{CTask<bool>} result provided by the \code{WhenAny} is used to tell the workflow whether or not the \code{AppOperation} managed to finish or if the timeout occurred first. If the AppOperation finishes first, then the return value is true. Otherwise, a timeout has occurred, and the boolean value is false.  If the boolean has false value, we set the application to be in what we refer to as inactive mode. In inactive mode, all requests and protocol-related messages such as phase messages and checkpoints are ignored. The application remains in inactive mode until all of the segments of view-change have been successfully completed. 

After the application is set to be inactive, the application must also stop any active normal protocol workflows. Theoretically, it is possible to keep existing protocol iterations alive during and after a view-change occurs. However, it would be rather wasteful because the \code{CTask}s are never finished. The \code{CTask}s are never stopped because the reactive streams never finish all of their reactive operators. Which in turn would unnecessarily drain the system of resources due to each time an item is emitted to the protocol \code{Source} objects, the old iterations would receive these items as well and would perform the checks as usual. The old protocol workflows would drop them quite quickly because the view number of the received message never matches the old protocols, but they are still unnecessary processes. Therefore, we decided it would be best to terminate any active protocol process when a view-change occurred. 

To accomplish this the application emits a clearly faulty phase message to secondary \code{Source<Phasemessage>} called \code{shutdownPhaseSource}. This \code{Source} object corresponds to the \code{Source<Phasemessage>} used in the \code{Merge} operator shown in \autoref{code:Pre-PrepareNonPrimary}. As we mentioned earlier in the \autoref{sec:prepare}, once the protocol workflow iterations receive the faulty pre-prepare message, it exits the function by throwing as well as catching a \code{TimeoutException}. In the case where the system as already received $2f$ view-change messages, the system emits the shutdown signal to the same \code{ShutdownSubject} \code{Source} object we use in the \code{ListenForShutdown} \code{CTask} function. Meaning the initialization for the view-change functionality does remain the same regardless of the method used to initiate it. The details in regards to handling view-change messages are described in detail in  \autoref{sec:viewchangeListener}. Line 29 in \autoref{code:timeout} is where the view-change functionality begins, and the \code{await} operator is used to make sure the view-change is completed before the protocol can go back to being active. 

\iffalse
A View-change is started whenever a replica deems the current primary to be faulty. In our implementation a replica can determine that a primary is faulty in two seperate ways. The first is the more common approach. We use a timeout functionality to detect irregular activity for the primary replica. The other condition that can start a view-change for the replica is when the replica has received a total of $2f$ view-changes messages from the other replicas in the \ac{pbft} network. In this situation the replica knows that the view-change exchange only needs its own view-change to be successful. 

In our case, we only support timeout functionality in the protocol workflow during the period where a replica is waiting for a pre-prepare phase message from the primary for a request the replica previously has received. \autoref{code:timeout} shows the source code for where the timeout functionality is initialized. \autoref{code:timeout} also shows how we initialize and how we stop the overall protocol workflow. On line nine-12 we can initialize the \code{AppOperation} within a \code{WhenAny} asynchronous function. The \code{WhenAny} creates a \code{CTask} for the two asynchronous \code{CTask} operations \code{AppOperation} and \code{ListenForShutdown}. The \code{CTask} created for \code{WhenAny} finishes whenever either of the \code{CTask} has finished its operation. In our case the \code{ListenForShutdown} is simply waiting for the given \code{Source} object \code{ShutdownSubject} to receive an item which constitutes a shutdown signal. When a timeout occurs for the protocol workflow, the timeout emits an item to the \code{ShutdownSubject}, which in turn results in \code{ListenForShutdown} finishes first. Each iteration of the protocol workflow is given a \code{CancellationToken} in order to stop the timeout functionality after it has received a pre-prepare message from the primary. To make sure we know whether or not the \code{AppOperation} finishes or not is determined by the boolean value returned from the \code{CTask} result from the \code{WhenAny} process. If the AppOperation finishes first then the return value is true, otherwise a timeout has occurred and the boolean value has false value.  If the boolean has false value, we set the application to be in what we refer to as inactive mode. In inactive mode all requests and protocol related messages such as phase messages and checkpoints are ignored. The application remains in inactive mode until all of the segments of view-change have been successfully completed. 

After the application has been set to inactive mode, any existing protocol workflows have to be stopped. Theoretically it is possible to keep existing protocol iterations alive during and after a view-change occurs. However, it would be rather wasteful as the \code{CTask} could never finish as the reactive streams never finish all of its reactive operators.  This in turn would unnecessarily drain the system of resources since each time an item is emitted to the protocol \code{Source} the old iterations would receive these items as well. However, the protocol would just end up dropping them fairly quickly due to the fact that the view number of the received message never matches the old protocols. Therefore, we decided it would be best to terminate any active protocol process when a view-change occured. To accomplish this the application emits a faulty phase message to secondary \code{Source<Phasemessage>} called \code{shutdownPhaseSource}. This \code{Source} object corresponds to the \code{Source<Phasemessage>} used in the \code{Merge} operator shown in \autoref{code:Pre-PrepareNonPrimary}. As we mentioned earlier in the \autoref{sec:prepare}, once the protocol workflow iterations receives the faulty pre-prepare message it exits the function by throwing as well as catching a \code{TimeoutException}. In the case where the system as already received $2f$ view-change messages, the system emits the shutdown signal to the same \code{ShutdownSubject} \code{Source} object we use in the \code{ListenForShutdown} \code{CTask} function. This means that the initialization for the view-change functionality does remain the same regardless of method used to initiate it. The details in regards to handling view-change messages are described in detail in  \autoref{sec:viewchangeListener}. Line 29 in \autoref{code:timeout} is where the view-change functionality begins and the \code{await} operator is used to make sure the view-change is completed before the protocol can go back to being active. 

(mention the inactive/active mode, mention timeout func, how the view-change functionality is repeated to stop faulty replicas from ruining everything)
(Action: )
(DONT FORGET ME!)
In inactive mode all protocol related messages and requests are denied by the main protocol execution. This mode is active until all segments of the view-change functionality is completed successfully. The view-change functionality differs from the other functionality due to the handling of timeout. It has already been mentioned that the view-change functionality starts once a replica exceeds its timeout before receiving a pre-prepare message. However, there are two additional timeouts present in the view-change functionality. These timeouts exist in order for the system to be absolutely sure that the new primary chosen by the $p = v ~mod~ R$ formula does not result in a faulty replica. If the formula does result in a faulty replica, then either the view-change process or the redo protocol process most likely is going to fail. Setting a timeout for these two functionalities, the protocol can recover from a potential frozen state and restart the view-change process by now selecting the next replica on the list. Specifically, the view number is incremented every time the view-change protocol starts, meaning a new primary is going to continue being swapped until a non-faulty primary is finally chosen. Unfortunately the current implementation only handles timeout at the start of the normal protocol workflow, which also gets stopped once the replica receives a pre-prepare message. This means the protocol workflow effectively gets stuck in the situation where the protocol fails during either handling prepare and commit messages. 

(Problems with timeout in our protocol workflow, how we currently stop the protocol execution when a view-change occur)
(Action: )
%(might be useful for the view-change evaluation)There were two main reasons for why this issue was not resolved in our implementation. The first reason was that timeout functionality relies on the \code{WhenAny} asynchronous function~\cite{WEB:whenany}. This function creates a \code{CTask} that is set to finish once either of the attached \code{Task}'s are completed. In our implementation this effectively is set to either the timeout is exceeded or the intended workflow completes. This was unfortunately not very well integrated with reactive \code{Source} objects. Even if the \code{WhenAny} moves on with the program once the timeout is reached, the protocol workflow cannot be exited due to the reactive \code{Source} is forced to finish all the operators before it is deemed completed. To solve this issue we use the \code{Merge} operator in order to enforce \code{Source} object to stop and dispose of the active reactive stream when a timeout occurs. The \code{Merge} operator requires that both the reactive streams that were to merge have the same format. This means that the stop signal to the \code{Merge} operator needed to also be a phase message for the pre-prepare reactive stream. The current workflow for handling the timeout functionality can be seen in \autoref{code:timeout}. The timeout is initialized with a cancellationtoken which can be used to stop the timeout process. This cancellationtoken is brought into the main protocol workflow so that the replica can cancel the timeout operation after it has received  a pre-prepare message. The timeout used in the current implementation is set to 10 seconds. The timeout operation has a reference to an active \code{Source} object which is the same \code{Source} object which is listened to at the function ListenForShutdown. When the timeout exceeds, the timeout function emits an item to the shutdown \code{Source} which in turn makes the \code{CTask} in ListenForShutdown to return before the AppOperation, which lets the program flow to continue. The AppOperation is still active as an asynchronous function, meaning we want to forcefully shut it down so as to avoid creating conflicts with the future emissions to the protocol \code{Source} object. To solve this we emit an obviously faulty phase message with an unique phase message type called \emph{End}. Thanks to the \code{Merge} operator, the pre-prepare reactive listener will finish and return the faulty pre-prepare message. As seen in \autoref{code:Pre-PrepareNonPrimary}, the protocol calls a timeout exception if the pre-prepare reactive listeners return the faulty phase message, meaning the protocol effectively shuts down as intended. 
\fi

\begin{figure}[H]
	\centering
	%\lstset{style=sharpc}
	\begin{lstlisting}[label = code:timeout, caption=Handling timeout for the normal protocol workflow and initiate the View-Change process, captionpos = b, basicstyle=\scriptsize]
CancellationTokenSource cancel = new CancellationTokenSource();
_ = TimeoutOps.AbortableProtocolTimeoutOperation( //starts timeout
  serv.Subjects.ShutdownSubject,
  10000,
  cancel.Token,
  scheduler
);
execute.Serv.ChangeClientStatus(req.ClientID);
bool res = await WhenAny<bool>.Of(
               AppOperation(req, execute, seq, cancel),
               ListenForShutdown(serv.Subjects.ShutdownSubject)
);
Console.WriteLine("Result: " + res);
if (res)
{
  Console.WriteLine($"APP OPERATION {seq} FINISHED");
  ...
}
else
{
  if (execute.Active)
  {
     Console.WriteLine("View-Change starting");
     execute.Active = false;
     serv.ProtocolActive = false;
     await scheduler.Schedule(() =>
        shutdownPhaseSource.Emit(new PhaseMessage(-1, -1, -1, null, PMessageType.End)
     ));
     await execute.HandlePrimaryChange2();
     Console.WriteLine("View-Change completed");
     serv.UpdateSeqNr();
     if (serv.CurSeqNr % serv.CheckpointConstant == 0 && serv.CurSeqNr != 0
        || serv.StableCheckpointsCertificate == null && serv.CurSeqNr > serv.CheckpointConstant
        || serv.StableCheckpointsCertificate != null &&
          (serv.StableCheckpointsCertificate.LastSeqNr + serv.CheckpointConstant) < serv.CurSeqNr)
        serv.CreateCheckpoint2(execute.Serv.CurSeqNr, PseudoApp);
     execute.Active = true;
     serv.ProtocolActive = true;
     serv.GarbageViewChangeRegistry(serv.CurView);
     serv.ResetClientStatus();
   \end{lstlisting}
\end{figure}


\subsubsection{View-Change functionality}
\autoref{code:viewchangefunc} shows the overall workflow for our implementation of the view-change functionality.  The workflow shown in \autoref{code:viewchangefunc} is responsible for initializing and keeping in order the two last segments of our view-change implementation.  Meaning it is responsible for updating the view information for the replica. Then the replica starts participating in the view-change process, which includes both creating and multicasting the replica`s view-change message, in addition to listening and handling any view-change messages received from the \ac{pbft} network. Once a valid view-change certificate is made, the replica starts the new-view phase of the view-change workflow. 

A view-change can pick a new non-faulty primary as its leader due to the next primary being solely dependent on the $p = v ~mod~ R$ formula. Therefore we needed to implement a functionality that could restart the view-change process indefinitely if the view-change exchange or new-view process were to fail or take too long. To handle this functionality, we currently use a mix of timeout operations and \code{goto} statements to reroute the program flow back to the beginning of the view-change process~\cite{WEB:goto}. Specifically, by restarting the view-change workflow whenever a timeout occurs, we force the view-change functionality to keep updating its view information. Therefore, the view number is incremented each time the view-change protocol restarts, meaning the new primary chosen for the new view is continually being swapped until a non-faulty primary is finally chosen. The timeout operations are initialized and used the same as they were for stopping the normal protocol workflow. This includes initializing them with cancellation tokens so that they can be stopped once the workflow has succeeded in performing the desired operation. Both the view-change exchange and the new-view process have their respective timeout operation. The view-change exchange has a timeout set to 10 seconds, just like the normal workflow, while the new-view process has a timeout set to 15 seconds. Extra time is added for the new-view process since it needs to reprocess at worst-case five requests for our implementation. The worst-case scenario number is determined by the checkpoint interval, which is set to five requests for our case. Therefore, the protocol logger could only have up to four finished requests where the last request is never fully processed by the protocol workflow. The \code{WhenAny} asynchronous function is once again used together with the timeout operations. If the view-change process is successful, the program moves on as intended. In the case where the timeout occurs first, then the \code{goto} statement moves the program back to the \emph{ViewChange} label we initialized at the very first line of the view-change workflow. Just like in the checkpoint workflow, we refer to the functionality that uses \code{Source} object to listen for view-change messages emitted by the server to create a valid view-change certificate as an iteration of a \emph{View-change Listener}. Depending on whether or not the server has received any view-change for the current next view number or not, the view-change workflow may need to initialize the view-change certificate and view-change listener. This initialization process occurs on lines 8-17. After the view information is updated and the view-change certificate and view-change listener is initialized, the replica creates a view-change message and multicasts this over the \ac{pbft} network. Afterwards the view-change workflow needs to wait for the view-change listener to keep adding view-change messages until the view-change certificate becomes valid by having $2f+1$ unique and valid view-change messages in its proof list. If this process takes too long, then the timeout occurs, and the view-change workflow starts anew. This functionality is visible on lines 45-47, where the \code{listener} refers to a function that listens on a \code{Source<bool>} that only returns true whenever it receives an item on its reactive stream. The \code{Source<bool>} is only emitted to by the server when the view-change listener is finished making a valid view-change certificate. Once the view-change exchange is complete, the view-change workflow moves on to the new-view phase. This functionality is performed in the \code{ViewChangeProtocol} referred to in the next \code{WhenAny} function at line 56-58. If this process takes too long, then the timeout once again is triggered, and the program starts at the top of the view-change workflow. The \code{ViewChangeProtocol} is responsible for having the new primary create a valid new-view message and multicast this message to the other replicas. The other replicas are responsible for validating that the information in the new-view is valid. Finally, the workflow will reprocess the request that needs to be processed again. Once the view-change workflow shown in \autoref{code:viewchangefunc} is finished, then the view-change is completed, and the application can once again start processing new client requests.

\iffalse
\autoref{code:viewchangefunc} shows the overall workflow for our implementation of the view-change functionality.  The workflow shown in \autoref{code:viewchangefunc} is responsible for initializing and keeping in order the two last segments of our view-change implementation.  Meaning it is responsible for updating the view information for the replica. Then the replica starts participating in the view-change process, which includes both creating and multicasting the replica's view-change message, in addition to listening and handling any view-change messages received from the \ac{pbft} network. Once a valid view-change certificate is made, the replica starts the new-view phase of the view-change workflow. 

It is possible for a view-change to pick a new non-faulty primary as its leader due to the next primary being solely dependent on the $p = v ~mod~ R$ formula. Therefore we needed to ensure that the view-change process could be indefinitely restarted in the case the view-change exchange or new-view process were to fail or take too long. To handle this functionality we currently use a mix of timeout operations and goto statements in order to reroute the program flow back to the beginning of the view-change process~\cite{WEB:goto}. Specifically, by restarting the view-change workflow whenever a timeout occurs, we force the view-change functionality to keep updating its view information. The view number is therefore incremented each time the view-change protocol restarts, meaning the new primary chosen for the new view is continually being swapped until a non-faulty primary is finally chosen. The timeout operations are initialized and used the same as they were for stopping the normal protocol workflow. This includes initializing them with cancellation tokens so that they can be stopped once the workflow has succeeded in performing the desired operation. Both the view-change exchange and the new-view process have their respective timeout operation. The view-change exchange has a timeout set to 10 seconds just like the normal workflow, while the new-view process has a timeout set to 15 seconds. Extra time is added for the new-view process since it needs to reprocess at worst case five requests for our implementation. This is because the checkpoint interval is set to five requests, meaning the protocol logger could potentially only have four finished protocol certificates where the last request is never fully processed by the protocol workflow.  The \code{WhenAny} asynchronous function is once again used together with the timeout operations. If the view-change process is successful the program moves on as intended. In the case where the timeout occurs first, then the \code{goto} statement moves the program back to the \emph{ViewChange} label we initialized at the very first line of the view-change workflow. Just like in the checkpoint workflow, we refer to the functionality that uses a \code{Source} object to listen for view-change messages emitted by the server in order to create a valid view-change certificate as an iteration of a view-change listener. Depending on whether or not the server has received any view-change for the current next view number or not, the view-change workflow may need to initialize the view-change certificate and view-change listener. This initialization process occurs from line eight-17. After the view information is updated and the view-change certificate and view-change listener is initialized the replica creates a view-change message and multicasts this over the \ac{pbft} network. Afterwards the view-change workflow needs to wait for the view-change listener to keep adding view-change messages until the view-change certificate becomes valid by having $2f+1$ unique and valid view-change messages in its proof list. If this process takes too long, then the timeout occurs and the view-change workflow starts anew. This functionality is visible on lines 45-47, where the \code{listener} refers to a function which listens on a \code{Source<bool>} that only returns true whenever it receives an item on its reactive stream. The \code{Source<bool>} is only emitted to by the server when the view-change listener is finished making a valid view-change certificate. Once the view-change exchange is complete the view-change workflow moves on to the new-view phase. This functionality is performed in the \code{ViewChangeProtocol} referred to in the next \code{WhenAny} function at line 56-58. If this process takes too long, then the timeout once again is triggered and the program starts at the top of the view-change workflow. The  \code{ViewChangeProtocol} is responsible for having the new primary create a valid new-view message and multicast this message to the other replicas. The other replicas are responsible for validating that the information in the new-view is valid. Finally the requests that need to be reprocessed are reprocessed. Once the view-change workflow is finished with the workflow shown in \autoref{code:viewchangefunc} then the view-change is completed and the application can once again start processing new client requests.
\fi

\begin{figure}[H]
	\centering
	%\lstset{style=sharpc}
	\begin{lstlisting}[label = code:viewchangefunc, caption=Overall source code for handling view-changes., captionpos = b, basicstyle=\scriptsize]
ViewChange:
//Initialize
Serv.CurPrimary.NextPrimary();
Serv.CurView++;
ViewChangeCertificate vcc;
if (!Serv.ViewMessageRegister.ContainsKey(Serv.CurView))
{
    vcc = new ViewChangeCertificate(Serv.CurPrimary, Serv.StableCheckpointsCertificate, null, null);
    Serv.ViewMessageRegister[Serv.CurView] = vcc;
    ViewChangeListener vclListener = new ViewChangeListener(
        Serv.CurView, 
        Quorum.CalculateFailureLimit(Serv.TotalReplicas), 
        Serv.CurPrimary, 
        Serv.Subjects.ViewChangeSubject, 
        false
    );
    _ = vclListener.Listen(vcc, Serv.ServPubKeyRegister, Serv.EmitViewChange, null);
}
else
{   
    vcc = Serv.ViewMessageRegister[Serv.CurView];
}
var listener = ListenForViewChange();
var shutdownsource = new Source<bool>();
ViewChange vc;
CDictionary<int, ProtocolCertificate> preps;
if (Serv.StableCheckpointsCertificate == null)
{
    preps = Serv.CollectPrepareCertificates(-1);
    vc = new ViewChange(0,Serv.ServID, Serv.CurView, null, preps);
}
else
{
    int stableseq = Serv.StableCheckpointsCertificate.LastSeqNr;
    preps = Serv.CollectPrepareCertificates(stableseq);
    vc = new ViewChange(stableseq,Serv.ServID, Serv.CurView, Serv.StableCheckpointsCertificate, preps);
} 

//View-change
Serv.SignMessage(vc, MessageType.ViewChange);
Serv.EmitViewChangeLocally(vc);
Serv.Multicast(vc.SerializeToBuffer(), MessageType.ViewChange);
CancellationTokenSource cancel = new CancellationTokenSource();
_= TimeoutOps.AbortableProtocolTimeoutOperationCTask(shutdownsource, 10000, cancel.Token);
bool vcs = await WhenAny<bool>.Of(
    listener, 
    ListenForShutdown(shutdownsource)
);
if (!vcs) goto ViewChange;
cancel.Cancel();
            
//New-view.
Source<bool> shutdownsource2 = new Source<bool>();
CancellationTokenSource cancel2 = new CancellationTokenSource();
_= TimeoutOps.AbortableProtocolTimeoutOperationCTask(shutdownsource2, 15000, cancel2.Token);
bool val = await WhenAny<bool>.Of(
    ViewChangeProtocol(preps, vcc), 
    ListenForShutdown(shutdownsource2)
);
if (!val) goto ViewChange;
cancel2.Cancel();
   \end{lstlisting}
\end{figure}

\paragraph{View-Change Listener Workflow}
\label{sec:viewchangeListener}
%\vspace{1cm}
%\parskip
\autoref{code:viewListener} shows the source code for our implementation of a view-change listener. Similar to the checkpoint listener, there are two separate ways to initialize an instance of the view-change listener. The first and most common approach is for a timeout to occur in the protocol workflow due to not receiving the pre-prepare message. This in turn, starts the view-change workflow for the replica, which initializes the view-change listener and view-change certificate for the following view number. The alternative way to start a view-change listener is for the server to receive a view-change message with a view number that it currently does not have in its view-change log. The server has a view-change log for each view-change certificate that the application is currently working on. This is for the case when the \ac{pbft} network is very large and the replicas may disagree upon the next view number. Therefore, in the situation where the replica has been set to inactive mode or is participating for another next view number, it needs to collect any view-change messages it can for other next view numbers.

The view-change listener deviates a bit from the protocol workflow and checkpoint listener. The main difference is that it requires the ability to call upon a shutdown emit in the case where the system already has gotten $2f$ view-change messages. The reason for this functionality is due to making the system more efficient. The replica does not need to wait for a timeout to occur if it already has received $2f$ view-change messages since the \ac{pbft} network only requires that replica`s view-change message to instantiate the new view. Therefore the process is sped up by calling a shutdown emit if it already has $2f$. Of course, this functionality is only helpful if the replica is still in active mode. This is the reason why we added the option toggle on whether or not to use the shutdown emit functionality. To utilize the shutdown functionality, the boolean parameter \code{Shutdown} must be set to true, and the view-change listener must have a callback address to the server shutdown emit function. The server function schedules an item to be sent to the same \code{Source<bool>} \emph{ShutdownSubject} that is used for the timeout functionality in the protocol workflow. This allows us to effectively stop the protocol workflow and set the application to be in inactive mode whenever the replica knows its vote can start a new view. 

The reactive listener performs relatively the same operators for the reactive stream as the normal protocol workflow did for its reactive handlers waiting for prepare and commit messages, just like the checkpoint listener. Firstly, we want only to accept view-change messages that belong to the same view number used for the view-change certificate that the view-change listener is handling. Secondly, the view-change messages received are validated to make sure that it is a valid view-change message. Assuming the validation process is successful, the view-change message is added to the proof list of the view-change certificate. The final reactive operator validates the view-change certificate to see if it has received a sufficient number of valid view-change messages in its proof list. After the view-change reactive listener is finished and a valid view-change certificate is ready, the callback function \emph{finCallback} calls the server to emit a signal to the view-change workflow that the view-change certificate is finished. Once it receives the signal, view-change workflow moves on to the next-view process of the view-change workflow. 

As can be seen in \autoref{code:viewListener}, there are two reactive chains used in the view-change listener. They both listen on the same \code{Source} object, but only one of them is active at a time. The first reactive chain belongs to the shutdown functionality and can be seen on lines 3-15. This one is used when the shutdown functionality is active for the view-change listener. The other reactive chain is seen on lines 17-26. They both perform the same initial \code{Where} clauses and add a valid view-change message to the view-change certificate. The only thing differentiating between the two is the last \code{Where} clause. The shutdown reactive chain determines whether or not the view-change certificate has received $2f$ unique view-change messages in its proof list, while the other has the traditional check of $2f+1$ unique view-change messages. Regardless of whether or not the shutdown functionality is used or not, the last reactive chain determines whether or not the view-change certificate is valid or not. Therefore, whenever the shutdown functionality has finished all of its operations, the program workflow naturally must wait in the second reactive chain for the view-change certificate to receive its last view-change message, which in likelihood should be replicas own view-change message.

\iffalse
\autoref{code:viewListener} shows the source code for our implementation of a view-change listener. Similar to the checkpoint listener, an instance of the view-change listener can be initialized in two seperate ways. The first and most common way is for a timeout to occur in the protocol workflow due to not receiving the pre-prepare message. This in turn starts the view-change workflow for the replica, which as a result initializes the view-change listener and view-change certificate for the next view number. The alternative way to start a view-change listener is for the server to receive a view-change message with a view number that it currently does not have in its view-change register. The server has a view-change registry for each of the view-change certificates that the application is currently working on. This is for the case when the \ac{pbft} network is very large and the replicas may disagree upon the next view number to move on to. Therefore, in the situation where the replica has been set to inactive mode or is participating another for another next view number, it needs to collect any view-change messages it can for other next view numbers.

The view-change listener deviates a bit from the protocol workflow and checkpoint listener. The main difference is that it requires the ability to call upon a shutdown emit in the case where the system already has gotten $2f$ view-change messages. The reason for this functionality is due to making the system more efficient. The replica does not need to wait for a timeout to occur if it already has received $2f$ view-change messages, since the \ac{pbft} network only requires that replica's view-change message in order for the new view to be instantiated. Therefore the process is sped up by calling a shutdown emit if it already has $2f$. Of course this functionality is only useful if the replica is still in active mode. This is the reason as to why we added the option toggle on whether or not to use the shutdown emit functionality. In order to use the shutdown functionality the boolean parameter \code{Shutdown} must be set to true, and the view-change listener must have a callback address to the server shutdown emit function. This function schedules an item to be sent to the same \code{Source<bool>} \emph{ShutdownSubject} that is used for the timeout functionality in the protocol workflow. This allows us to effectively stop the protocol workflow and set the application to be in inactive mode whenever the replica knows its vote can start a new view. 

The reactive listener performs relatively the same operators for the reactive stream as the protocol workflow did for its reactive handlers for prepare and commit messages, just like the checkpoint listener. Firstly, we want to only accept view-change messages that belong to the same view number used for the view-change certificate that the view-change listener is responsible for. Secondly the view-change messages received are validated to make sure that it is a valid view-change message. Assuming the validation process is successful, the view-change message is added to the proof list of the view-change certificate. The final reactive operator validates the view-change certificate to see if it has received the sufficient number of valid view-change messages in its proof list. After the view-change reactive listener is finished and a valid view-change certificate is ready, the callback function \emph{finCallback} calls the server to emit a signal to the view-change workflow that the view-change certificate is finished and can then move on to the next-view process of the view-change workflow. As can be seen in \autoref{code:viewListener}, there are two reactive chains used in the view-change listener. They both listen on the same \code{Source} object but only one of them is active at a time. The first reactive chain belongs to the shutdown functionality and can be seen on lines three-15. This one is used when the shutdown functionality is active for the view-change listener. The other reactive chain is seen on lines 17-26. They both perform the same initial \code{Where} clauses and add a valid view-change message to the view-change certificate. The only thing differentiating between the two is the last \code{Where} clause. The shutdown reactive chain determines whether or not the view-change certificate has received $2f$ unique view-change messages in its proof list, while the other has the traditional check of $2f+1$ unique view-change messages. Regardless of whether or not the shutdown functionality is used or not, the last reactive chain determines whether or not the view-change certificate is valid or not. Therefore, whenever the shutdown functionality has finished all of its operations, the program workflow naturally must wait in the second reactive chain for the view-change certificate to receive its last view-change message, which in likelihood should be its own view-change message. 
\fi

\iffalse
As previously mention in \autoref{sec:view-change} the goal of a view-change is to successfully replace a faulty primary replica with another non-faulty replica. In order for a primary change to be successful, the replicas in the \ac{pbft} network needs to agree upon the state the program continues on after the primary change has occurred. Furthermore the view-change must ensure that the new replica selected for primary responsibility is not faulty. 

The operations to ensure these criteria were briefly mentioned in \autoref{sec:view-change}. Although in total there are a quite lot of operations needed for a successful view-change to take place. However, it is possible to divide up the operations into two segments based on which goal the operations attempt to fulfill. Excluding the processes of shutting down the protocol execution, the first part of the view-change process is for the replicas in the network to agree on that a view-change is necessary. This goal is achieved by having the replicas multicast and listen for view-change messages. Since the next primary is determined by the formula $p = v ~mod~ R$, \ac{pbft} doesn't require any election process. The view-change messages instead contains information of the replicas current checkpoint information as well as current state of the logged certificates. This is so that the new primary can have all the relevant information to create the new state for the \ac{pbft} system. The goal of the second segment is to initialize the \ac{pbft} system state after the view-change is finished. This goal is fulfilled by looking at the current stable checkpoint and the current protocol certificates stored in memory. In order to make sure that requests were not fully processed before the view-change occured. The \ac{pbft} needs to redo each of the requests stored in the logger up to the highest sequence number seen in the \ac{pbft} system. Thankfully, due to stable checkpoints, the process does not need to take into account every single request ever processed. The new primary is responsible for starting this process by creating and multicast a new-view message. This message acts as an introduction letter, telling the other replicas in the network that it is the new primary and additionally provide a view-change certificate proving this fact. The new-view message also contain a list of pre-preprepares which are created from the information stored within the protocol certificates in the view-messages received. This new-view message is validated by the other replicas. If the replicas deem the information in new-view message as valid, the replicas will use these pre-prepares message to create prepare and commit messages and redo the \ac{pbft} algorithm for these pre-prepares. The system is finally finished with the view-change once all the pre-prepares have stored their respective two protocol certificates. 

As for implementing this functionality, our implementation can be divided into four segments. The first consist of the timeout functionality that when triggers puts the application into non-active mode. The second part consist of updating the view data, creating view-change messages, multicast these view-changes over the \ac{pbft} network and finally store the collection of view-changes until quorum has been reached. The third consist of creating and validating functionality for new-view message. Finally the last segment consist of the redo protocol functionality. 

In non-active mode all protocol related messages and requests are denied by the main protocol execution. This mode is active until all four segments of the view-change functionality as been completed successfully. The view-change functionality differs from the other functionality due to the handling of timeout. It has already been mention that the view-change functionality start once a replica exceeds its timeout before receiving a pre-preprepare message. However, there are two additional timeout present in the view-change functionality. These timeout exists in order for the system to be absolute sure that the new primary chosen by the $p = v ~mod~ R$ formula does not result in a faulty replica. If the formula does result in a faulty formula, then either view-change process or redo protocol process will most likely fail. Setting a timeout for these two functionalities, the protocol can recover from a potential frozen state and restart the view-change process by now selecting the next replica on the list. Essentially, the view number is incremented every time the view-change protocol changes, meaning a new primary is selected until a non-faulty primary is chosen. Unfortunately the current implementation only handles timeout at the start of the normal protocol workflow, which also gets stopped once the replica receives a pre-prepare message. This means the protocol gets effectively stuck in the case where the protocol fails at handling prepare and commit messages. There were to main reason for why this issue was not resolved in our implementation. The first reason was that timeout functionality relies on the \code{WhenAny} asynchronous function~\cite{WEB:whenany}. This function creates a \code{Task} that is set to finish once either of the attached \code{Task}'s completes. In our implementation this effectively is set to either the timeout is exceeded or the process that is waited for completes. This was unfortunately not very well integrated with reactive listeners, as it is forced to finish all the operators before it is deemed completed. It required the \code{Merge} operator in order to enforce reactive listeners to stop and dispose of the active reactive stream when a timeout occured. The \code{Merge} operator required that both the reactive streams that were to merge had the same format. This means that the stop signal to the \code{Merge} operator needed to also be a phase message for the pre-prepare reactive stream. The current workflow for handling the timeout functionality can be seen in \autoref{code:timeout}. The time is first initialized with a cancellationtoken which is brought into the main protocol workflow so that the protocol can cancel the timeout when it receives a pre-prepare message. The timeout used in the current implementation is set to ten seconds. The timeout gets a reference to an active \code{Source} object which is the same \code{Source} which is listened to at the function ListenForShutdown. When the timeout exceeds, the timeout function will emit a message to the shutdown \code{Source} which in turn makes the \code{CTask} in ListenForShutdown to return before the AppOperation, which lets the program flow to continue. The AppOperation is still active as an asynchronous function, meaning we want to forcefully shut it down so as to avoid creating conflicts with the future emits to the protocol \code{Source} object. To solve this we emit an obviously faulty phase message with an unique phase message type called \emph{End}. Thanks to the \code{Merge} operator, the pre-prepare reactive listener will finish and returns the faulty pre-prepare message. As seen in \autoref{code:Pre-PrepareNonPrimary}, the protocol calls a timeout exception if the pre-prepare reactive listeners returns the faulty phase message, meaning the protocol effectively shuts down as intended.   
\begin{figure}[H]
	\centering
	%\lstset{style=sharpc}
	\begin{lstlisting}[label = code:timeout, caption=Handling timeout for the normal protocol workflow and initiate View-Change, captionpos = b, basicstyle=\scriptsize]
CancellationTokenSource cancel = new CancellationTokenSource();
_ = TimeoutOps.AbortableProtocolTimeoutOperation( //starts timeout
   serv.Subjects.ShutdownSubject,
   10000,
   cancel.Token,
   scheduler
);
execute.Serv.ChangeClientStatus(req.ClientID);
bool res = await WhenAny<bool>.Of(
                AppOperation(req, execute, seq, cancel),
                ListenForShutdown(serv.Subjects.ShutdownSubject)
);
Console.WriteLine("Result: " + res);
if (res)
{
   Console.WriteLine($"APP OPERATION {seq} FINISHED");
   ...
}
else
{
   if (execute.Active)
   {
      Console.WriteLine("View-Change starting");
      execute.Active = false;
      serv.ProtocolActive = false;
      await scheduler.Schedule(() =>
         shutdownPhaseSource.Emit(new PhaseMessage(-1, -1, -1, null, PMessageType.End)
      ));
      await execute.HandlePrimaryChange2(); 
      Console.WriteLine("View-Change completed");
      serv.UpdateSeqNr();
      ...
    \end{lstlisting}
\end{figure} 
\fi
\iffalse
The view-change exchange segment of the code starts by first setting the replica into the next view by incrementing its view number. The next operation sets the replicas view-change certificate. This step is dependent on whether or not the replica has received previously received view-change messages from another replica. If the replica has not received any view-messages from other replicas than it initializes the view-change certificate and initializes the view-change reactive listener. Info about the rest of the view-change process in the main workflow...

The view-change listener deviates a bit from the other reactive listeners. The main difference is that it also requires the ability to call upon a shutdown emit in the case where the system already has gotten $2f$ view-change messages. The reason for this functionality is mostly due to making the system more efficient. The replica does not need to wait for a timeout to occur if it already has received $2f$ view-change messages since the \ac{pbft} network only requires that replica's view-change in order for the new view to be initialized. Therefore the process is speed up by calling for a shutdown emit if already has $2f$. Ofcourse this functionality is only useful if the replica is still in active mode. This is the reason as to why the option to not trigger the shutdown emit is an option. Other than that the reactive listener performs relatively the same operators for the reactive stream. Firstly, we want to only accept view-change message that belongs to the same next view number as the replica. Secondly the view-change messages received are validated to make sure that it is a valid view-change message. Assuming the validation process is successful, the view-change message is added to the view-change certificate proof list. The final reactive operator validates that the view-change certificate to see if it has received the sufficient number of valid view-change messages in its proof list. After the view-change reactive listener is finished and a valid view-change certificate is ready, the callback function \emph{finCallback} calls the servers to emit a signal to the view-change workflow that the view-change certificate is finished and can move on with the next step of the view-change process. 
 
segment from motivation, rewrite and get it in the main text somehow!
This could in theory also apply to the view-change description as it is divided into several detailed steps. However, there are several factors which lead to the view-change functionality being split into three separate, but nested, functions. The first reason being that view-changes require the ability to restart the processes in the case where the request processing remains stationary for too long. To handle this functionality we currently use a mix of timeout operations and goto statements in order to reroute the program flow back to the beginning of the view-change process~\cite{WEB:goto}. The second reason, which also applies to checkpoints, is that the view-change process can be initialized early by receiving view-change messages from other replicas. This may seem similar to protocol operations since it is initialized by client requests, however the difference lies in the amount of messages required to initialize the process. Currently, the server needs to support the functionality of starting reactive listeners for view-changes if it ever receives a view-change, however the view-change process itself doesn't start until either the timeout occurs or the replica has received $2f$ messages. Because of this functionality, keeping the code completely synchronous and centered around a single function is not possible. As for checkpoints, because the checkpoint processes can be initialized whenever, and the majority of the time spent for checkpoints is used waiting for a replica to receive $2f+1$ unique checkpoints with identical sequence numbers, the source code cannot be centered around a single function.
\fi

\begin{figure}[H]
	\centering
	%\lstset{style=sharpc}
	\begin{lstlisting}[label = code:viewListener, caption=Source code for View-Change Listener, captionpos = b, basicstyle=\scriptsize]
if (Shutdown && shutdownCallback != null)
{
   Console.WriteLine("With shutdown");
   await ViewBridge
      .Where(vc => vc.NextViewNr == NewViewNr)
      .Where(vc => vc.Validate(keys[vc.ServID], ServerViewInfo.ViewNr))
      .Scan(vcc.ProofList, (prooflist, message) =>
      {
        prooflist.Add(message);
        return prooflist;
      })
      .Where(_ => vcc.ShutdownReached(FailureNr))
      .Next();
   Console.WriteLine("Calling shutdown");
   shutdownCallback();
}
await ViewBridge
   .Where(vc => vc.NextViewNr == NewViewNr)
   .Where(vc => vc.Validate(keys[vc.ServID], ServerViewInfo.ViewNr))
   .Scan(vcc.ProofList, (prooflist, message) =>
   {
     prooflist.Add(message);
     return prooflist;
   })
   .Where(_ => vcc.ValidateCertificate(FailureNr))
   .Next();
Console.WriteLine("Finished Listen view changes");
finCallback();
    \end{lstlisting}
\end{figure}

\paragraph{New-View Workflow}
\vspace{1cm}

The goal of this segment is to initialize the new common \ac{pbft} protocol state of the system after the view-change. The protocol state is determined by looking at the current stable checkpoint and the different protocol certificates obtained from the view-change messages. Thankfully the stable checkpoint can choose the last sequence number in which the majority of the replicas have agreed upon the application state. On the other hand, requests that are processed with higher sequence numbers do not have that guarantee. Therefore, the system is unsure whether or not the majority of replicas have actually managed to process these requests appropriately. The only way to be sure none of the protocol certificates are corrupted or incomplete is to redo their processing. Since each replica sends copies of their protocol certificates stored and their last checkpoint proof in their view-change message, it is possible to determine the requests that have to be reprocessed, including vital information needed to reprocess the request. The new primary is given the task to ready pre-prepare messages for each request that has to be reprocessed. In the unfortunate situation where there does not exist a protocol certificate record for a request that does need to be reprocessed, the digest of the request is set to \code{null}, indicating a missing operation. The list of pre-prepare phase messages created by the new primary is added to a new view message and multicasted to the other replicas in the \ac{pbft}. The new-view message also contains the view-change certificate created from the view-change message exchange. In this way, the new-view message is essentially a message to the other replicas in the network, relaying that it is the new primary of the \ac{pbft} system, and here is the proof to show it. The other replicas validate the new-view message they receive from the new primary. If the information in the new-view message is incorrect, the replica treats this as a failure of the new-view phase of the workflow and restarts the view-change process with the following view number. Otherwise, the replicas join the new primary in reprocessing the requests anew. 

The source code for the reprocessing functionality can be seen in \autoref{code:redoprotocol}. The code here is clearly very similar to the normal protocol workflow shown earlier in \autoref{code:PrepareAndCommit} as we are literally attempting to do the same operations. The most obvious difference between the two workflows is the lack of pre-prepare phase for the redo processing since all pre-prepare phase messages have already been made and multicasted to the replicas. Since we know that the reprocess functionality will be repeated until all of the pre-prepare phase messages for the protocol state are reprocessed, we decided it was best to iterate the reprocess functionality over the list of pre-prepare messages. As the pre-prepare phase messages have already been exchanged with the other replicas, the new primary only needs to listen and wait for the prepare phase messages from the other replicas during the prepare phase. Just like in the normal workflow, every replica, including the new primary, has to participate in the commit phase by creating a commit message and multicasting it over the \ac{pbft} network. The reactive operators used for the reactive chain are the same as those used in the prepare and commit phase in the normal protocol workflow. Although to avoid potentially cause issues with the Cleipnir execution engine, we decided to use a different \code{Source<PhaseMessage>} object for the reprocessing functionality. This \code{Source} object is known as \emph{ReMesBridge} as can be seen on line 16 and 27. The reason why we decided to use different \code{Source} objects to differentiate between the normal workflow and the reprocess workflow is because we wanted to avoid potentially scheduling phase messages for the wrong workflow. From our experience scheduling for the same \code{Source} object for two separate workflows can, in the best case, be easily filtered out by the \code{Where} clauses. However, in the worst-case scenario, it can freeze the program due to scheduling an emit without any listeners for said \code{Source} object, when the program still needs to schedule other additional operations before the listeners are initialized. Therefore, to avoid this issue, we instead use two \code{Source<PhaseMessage>}, where the server schedules the phase message to be emitted to the appropriate \code{Source} object based on whether the application is active or inactive. 

Unfortunately, just like the protocol workflow, the redo functionality can fail and get stuck. On the other hand, this is not a significant issue as the view-change workflow can move on to the next view number and restart the view-change workflow. This means the application never gets thoroughly stuck, even in the case the redo functionality fails. The redo functionality can fail if too many messages are received and emitted before the reactive listeners are ready. As the redo functionality immediately moves on to reprocess the next pre-prepare message whenever it is finished with another, it is possible to lose the phase messages for the next one if the other replicas are a lot faster. To mitigate the loss of phase messages, we decided to add wait periods where we know it is possible to miss phase messages. The first wait period is set to half a second and is performed right after the reactive listeners are defined on line 38. The other wait period is set to three-quarters of a second and is performed after the prepare phase is finished on line 53. Once the redo functionality has successfully reprocessed all of the pre-prepare phase messages for previous requests, the protocol logger should now have the two valid prepare certificates for each sequence number up to the point when the view-change was initiated. The view-change is then completed, and the application is once again set to active mode. We also perform garbage collection for the view-change log once the view-change is deemed successful, as seen in \autoref{code:timeout}.

\iffalse
The goal of this segment is to initialize the new common \ac{pbft} protocol state of the system after the view-change. The protocol state is determined by looking at the current stable checkpoint and the different protocol certificates obtained from the view-change messages. Thankfully the stable checkpoint can determine the last sequence number in which the majority of the replicas have agreed upon the application state. On the other hand, requests that are processed with higher sequence numbers do not have that guarantee. The system is therefore unsure whether or not the majority of replicas has actually managed to process these requests properly. The only way to be sure none of the protocol certificates are corrupted or incomplete is to redo their processing. Since each replica sends copies of their protocol certificates stored after their last checkpoint in their view-change message,  it is possible to determine both the requests that have to be reprocessed including intergral information needed to reprocess the request. The new primary is given the task to ready pre-prepare messages for each of the requests that has to be reprocessed. In the unfortunate situation where there does not exist a protocol certificate record for a request that does need to be reprocessed, the digest of the request is set to \code{null}, indicating a missing operation. The list of pre-prepare phase messages created by the new primary are added to a new view message and multicasted to the other replicas in the \ac{pbft}. The new-view message also contains the view-change certificate created from the view-change message exchange. In this way the new-view message is essentially a message to the other replicas in the network relaying that it is the new primary of the \ac{pbft} system and here is the proof to show it. The other replicas validate the new-view message they receive from the new primary. In the case where the information in the new-view message is incorrect, the replica treats this as a failure of the new-view phase of the program and restarts the view-change process with the next view number available. Otherwise the replicas join the new primary in reprocessing the requests anew. 

The source code for the reprocessing functionality can be seen in \autoref{code:redoprotocol}. The code here is obviously very similar to the normal protocol workflow shown earlier in \autoref{code:PrepareAndCommit} as we are literally attempting to do the same operations. The most obvious difference between the two workflows is the lack of pre-prepare phase for the redo processing, since all of the pre-prepare phase messages have already been made and multicasted to the replicas. Since we know that the reprocess functionality is going to be repeated until all of the pre-prepare phase messages for the protocol state are reprocessed, we decided it was best to simply iterate the reprocess functionality over the list of reprocess functionality. As the pre-prepare phase messages have already been exchanged with the other replicas, the new primary only needs to listen and wait for the prepare phase messages from the other replicas during the prepare phase. Just like in the normal workflow, every replica, including the new primary, has to participate in the commit phase by creating a commit message and multicasting it over the \ac{pbft} network. The reactive operators used for the reactive chain are the same as the one used in the prepare and commit phase in the normal protocol workflow. Although, to avoid potentially cause issues with the Cleipnir execution engine, we decided to use a different \code{Source<PhaseMessage>} object for the reprocessing functionality. This \code{Source} object is known as \emph{ReMesBridge} as can be seen on line 16 and 27. The reason why we decided to use different \code{Source} objects to differentiate between the normal workflow and the reprocess workflow is because we wanted to avoid potentially scheduling phase messages for the wrong workflow. From our experience scheduling for the same \code{Source} object for two separate workflows can at the best case be easily filtered out by the \code{Where} clauses. However, in the worst case scenario the program can be freezed due to scheduling an emit without any listeners for said \code{Source} object, when the program still needs to schedule other additional operations before the listeners are initialized. Therefore, in order to avoid this issue we instead use two \code{Source<PhaseMessage>}, where the server schedules the phase message to be emitted to the appropriate \code{Source} object based on whether the application is active or inactive. Unfortunately, just like the protocol workflow it is possible for the redo functionality to fail and get stuck. On the other hand, this is not a major issue as the view-change workflow simply moves on to the next view number and restarts the processes in the view-change workflow. This means the application never gets fully stuck even in the case the redo functionality fails. The redo functionality can fail if too many messages are received and emitted before the reactive listeners are ready. As the redo functionality immediately moves on to reprocess the next pre-prepare message whenever it is finished with another, it is possible to lose the phase messages for the next one if the other replicas are a lot faster. To mitigate the loss of phase messages, we decided to add wait periods where we know it is possible to miss phase messages. The first wait period is set to half a second and is performed right after the reactive listeners are defined on line 38. The other wait period is set to three-quarters of a second and is performed after the prepare phase is finished on line 53. Once the redo functionality has successfully reprocessed all of the pre-prepare phase messages for previous requests, the protocol logger should now have the two vald prepare certificates for each of the sequence numbers up to the point when the view-change was initiated. The view-change is thereby completed and the application is once again set to active mode. We also perform garbage collection for the view-change logger once the view-change is deemed successful as seen in \autoref{code:timeout}.
\fi

\begin{figure}[H]
	\centering
	\begin{lstlisting}[label = code:redoprotocol, caption=Redo Protocol Functionality, captionpos = b, basicstyle=\scriptsize]
foreach (var prepre in oldpreList)
{
     var precert = new ProtocolCertificate(
	    prepre.SeqNr, 
	    prepre.ViewNr, 
	    prepre.Digest, 
	    CertType.Prepared, prepre
     );
     var comcert = new ProtocolCertificate(
        prepre.SeqNr, 
        prepre.ViewNr, 
        prepre.Digest, 
        CertType.Committed
     );
     Serv.InitializeLog(prepre.SeqNr);
     var preps = ReMesBridge
     	         .Where(pm => pm.PhaseType == PMessageType.Prepare)
                 .Where(pm => pm.SeqNr == prepre.SeqNr)
                 .Where(pm => pm.ValidateRedo(Serv.ServPubKeyRegister[pm.ServID], prepre.ViewNr))
                 .Scan(precert.ProofList, (prooflist, message) =>
                 {
                    prooflist.Add(message);
                    return prooflist;
                 })
                 .Where(_ => precert.ValidateCertificate(FailureNr))
                 .Next();
     var coms = ReMesBridge
                 .Where(pm => pm.PhaseType == PMessageType.Commit)
                 .Where(pm => pm.SeqNr == comcert.SeqNr)
                 .Where(pm => pm.ValidateRedo(Serv.ServPubKeyRegister[pm.ServID], prepre.ViewNr))
                 .Scan(comcert.ProofList, (prooflist, message) =>
                 {
                    prooflist.Add(message);
                    return prooflist;
                 })
                 .Where(_ => comcert.ValidateCertificate(FailureNr))
                 .Next();
     await Sleep.Until(500);              
     if (!Serv.IsPrimary())
     {
        var prepare = new PhaseMessage(
            Serv.ServID, 
            prepre.SeqNr, 
            prepre.ViewNr, 
            prepre.Digest, 
            PMessageType.Prepare
        );
        Serv.SignMessage(prepare, MessageType.PhaseMessage);
        Serv.Multicast(prepare.SerializeToBuffer(), MessageType.PhaseMessage);
        Serv.EmitRedistPhaseMessageLocally(prepare);
     }
     await preps;
     await Sleep.Until(750);
     Console.WriteLine("Prepare certificate: " + precert.SeqNr + " is finished");
     Serv.AddProtocolCertificate(prepre.SeqNr, precert);

     var commes = new PhaseMessage(
        Serv.ServID, 
        prepre.SeqNr, 
        prepre.ViewNr, 
        prepre.Digest, 
        PMessageType.Commit
     );
     Serv.SignMessage(commes, MessageType.PhaseMessage);
     Serv.Multicast(commes.SerializeToBuffer(), MessageType.PhaseMessage);
     Serv.EmitRedistPhaseMessageLocally(commes);
     await coms;
     
     Console.WriteLine("Commit certificate: " + comcert.SeqNr + " is finished");
     Serv.AddProtocolCertificate(prepre.SeqNr, comcert);
}
	\end{lstlisting}
\end{figure}

\subsubsection{View-Change Evaluation}