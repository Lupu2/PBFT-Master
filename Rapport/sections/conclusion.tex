\chapter{Conclusion}
\label{chapter:Con}
This chapter concludes the thesis by first listing the lessons we learned while working on this thesis. Then we list the potential future work which can be applied to the PBFT implementation.
Finally a conclusion is drawn for the work performed for this thesis.

\input{sections/learned}

\section{Future Work}
%1 mention fixing the broken public key system, and give examples(if you can think of any).
%2 potential things: 1. fix it so that the protocol workflow can handle any message being received in any order or 2. Implement a timeout process for the commit section so that the process can not become stuck in any scenario. Both are somewhat needed, but I have no idea how I can handle waiting for prepares before receiving the pre-prepare.
%3 Fix persistency. We believe we layed most of the foundation in regards to getting the system to be persistent. However, as mention in imp 2 issues are mainly present. 1. figure out a way to get rid of the original source referanse/access the original source reference so there is no longer duplicate requests. 2. Something is wrong with the synchronization. Not sure what is the cause, assume its the synchronization process is not fully finished before a new request is added. 
% 4 Generally make the application and client more interessting. Currently the application state is a simple list of commands written to the console. Make the application actually perform a set of commands, and redesign the client to accomodate for this change. 
As mentioned in \autoref{chapter:Design} our current cryptographic signature architecture is susceptible to impersonation  and sybil attacks. Clearly keeping public keys ephemeral and generated uniquely before start up is not viable if a system supports persistency. Having an unchanging private and public keys is not recommended either as this would make it more likely for an attack to be able to brute force the private key, which as a result put the system in danger. The simplest solution would be to generate a couple unique key pairs for each replica and have these stored securely or given by a trusted separate system. This system could be for instance be a database where the cryptographic keys are stored encrypted. During system startup or during certain scenarios, such as view-changes and or system restarts, the replica reassigns its current cryptographic and re-establishes its secret key with the other replicas in the system. The other replicas only accepts the renewed connection if the separate system acknowledges that the public key given matches one of the unique public keys that replica can have.

Currently we are using digital signatures scheme for type of message, with the exception of the session message, which is in some cases unnecessary and only slows down the system. The desired alternative is to follow the original PBFT system model and use MAC's for authentication instead, as this would be more efficient. Although, we still recommend to continue to use the digital signature structure for view-change and new-view messages. Otherwise the view-change workflow would need to be redesigned to follow the more advanced workflow described in Castro's and Liskov's updated paper for PBFT~\cite[p.~410-414]{PAPER:PBFTRecovery}. 

The protocol workflow currently suffers from the inability to handle pre-prepare and prepare being received out of order. In addition prepare messages can also be lost if it received before the prepare listener is initialized. As described in \autoref{sec:protocolwork} ...

Our current application does not fully support persistency. As mention in \autoref{chapter:Imp} there are currently a few issues that needs to be handled in order for the persistency to work for our implementation. As of now ...

\section{Conclusion}
