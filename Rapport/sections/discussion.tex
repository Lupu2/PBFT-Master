\chapter{Discussion}
\label{chapter:Dis}
Summaries your arguments for why these tools helped/hindered the implementation of the PBFT algorithm. And perhaps give your thoughts on the matter.

\section{Protocol Abstraction}
TODO set a better title for this once you realize the word for code accuracy to its protocol description
\section{Asynchronous workflow}
\section{Usage of Cleipnir}

\subsection{Reactive Operators}
(This section is about: discussing the fact that there exist two implementations for view-change and checkpoint, and their differences. perhaps better for evaluation?)
(Action: move this to discussion/imp discussion, benefits of using reactive operations vs object directly.)
Probably be moved again as this is not a summary!
There currently exist two different implementations for checkpointing and view-changes. Both versions are still documented in the source code, where the second implementations and preferred implementations have the letter 2 at the end of its name. The workflow for both of them remains practically the same. The main difference between the two lies in how the implementations handle  the creation of certificates. A certificate is not deemed valid until it has received $2f+1$ unique and valid message for the corresponding message type. The second implementation performs the message validation, adding a message to proof list and proof list validation over a \code{Source} object using reactive operators. Meanwhile the first implementation performs these same operations for certificates inside the checkpoint certificate itself inside. The processes are performed sequentially once the append function is called with a message. Regardless of which implementation is used, once the certificates are deemed valid, another emit has to be called for another \code{Source} object to allow the view-change and checkpoint operations to continue with their next operations. Essentially this \code{Source} acts as a signal to tell the workflow to continue with the next operations. The first implementation is required to add a callback function to the certificate object in order to call the server to emit the signal. The second implementation is initialized with the callback function reference, allowing it to easily make a call once all the reactive operators are completed. The second implementation was made in order to accommodate the need for more reactive operations in our application. From our experience the second implementation generally performed better than the first implementation and was also for the most part more consistent, and easier to code. The first implementation sometimes encountered issues with the callback function, especially the view-change implementation. 

\subsection{Persistency}
TEMPLATE from Motivation!
Currently the \ac{pbft} implementation does not support functional persistency. The reason why the persistency  does not work properly is uncertain. There are two main issues as of now. The first issue is that the protocol logger for some reason does not persist all the entries in the logger. As of now, no distinguishable pattern has been found with the data which is lost. Either way, losing certificates in the logger does create big problems. The other problem is that some of the \code{Source} objects that are linked to the server get duplicated when persisted. This means that in the persisted system there suddenly exist two \code{Source} objects with the exact same reference. This becomes a problem, because each time the server emits a message to the duplicated \code{Source} object, it emits the message to both the original and duplicate \code{Source}. This in turn can cause two identical iterations of the protocol workflow to occur. This even includes storing the resulting protocol certificates to the logger with the same sequence number, leading to scenarios where the logger suddenly has four certificates recorded for a single sequence number. The logger is only meant to store a maximum of two protocol certificates for a protocol iteration, so this is quite the issue for future protocol states.