\chapter{Introduction}
\section*{HUSK Å GJØRE OM ALLE CITATENE SOM HAR MED PAPER/BOK til format [ref, p.sidetall]!}
Systems today are required to be both efficient, secure, and reliable. Due to these factors most firmware and software today are organized over multiple systems in what we call a \textit{distributed system}~\cites{WEB:DistSys}[p.~16]{BOOK:MVstandver3}. In distributed systems, network nodes are required to share and collaborate so that the systems can agree on an overall state of the system. This state must remain consistent for the systems even in the event of failure, or in some cases malicious intent. A distributed system must be able to act as if its a single system, even when in reality it is comprised of multiple systems~\cite[p.~18]{BOOK:MVstandver3}. Advanced and technical consensus algorithms are currently being used to handle this functionality. 
%The more commonly used consensus algorithms for distributed systems being Paxos, Raft and Practical Byzantine Fault Tolerance(PBFT)\cite{WEB:ConsesAlgo}. 
However, most consensus algorithms are known for being difficult to fully understand and can be even more difficult to implement due to the unreliable nature of distributed networks~\cites[p.~459]{BOOK:MVstandver3}[p.~13]{PAPER:EivindPaper}. Because of this, alternative ways to describe and implement existing consensus algorithms are being discussed.

%TODO Include segment about reactive and async in introduction, brief introduction as to what they are, how much they are used as they are mention in the next segment.
%Basically insert motivation for why we should care about testing async/reactive programming for implementing consensus algorithm

%Two of the difficulties usually encountered when designing a consensus algorithm are threading and properly handling messages from other nodes in the system. Consensus algorithm must do work concurrently over multiple threads. Maintaining the state of the program can be quite challenging and easy to encounter issues in regards to deadlocks or causing inconsistent state. Asynchronous programming ...

The university of Stavanger have previously published work that implements popular consensus algorithms, such as Paxos and Raft~\cite{WEB:ConsesAlgo}, in a simplified manner using frameworks that support reactive programming. In particular, "Cleipnir - Framework Support for Fault-tolerant Distributed Systems"~\cite{PAPER:PaxosCleipnir} and "Implementing a Distributed Key-Value Store Using Corums"~\cite{PAPER:EivindPaper} uses the .NET framework now known as \textit{Cleipnir}~\cite{DOC:Cleipnir}. 
These two works are predecessor for this thesis which intends to use Cleipnir in order to implement another popular consensus algorithm.
Cleipnir is a .Net framework that is designed to help making implementations for consensus algorithms simpler for the developer.

Our goal for this thesis is to use the Cleipnir framework to implement the Practical Byzantine Fault Tolerance(PBFT) consensus algorithm using functionality from both asynchronous programming and reactive programming. The desired PBFT implementation should be devised using both async/await functionality existing in the .Net framework~\cite{DOC:AsyncAwait} and reactive event handling which Cleipnir has support for. Using these tools, the end goal is for the workflow of PBFT to be simple to understand as well as easier for others to recreate. In order to accomplish these goal we are looking into Cleipnir current support for reactive programming. We also look at the current workflow of modern asynchronous programming for .Net. A detailed summary of the PBFT algorithm and its operations are also given. Additionally, Cleipnir persistency functionality is also studied.
In the end the question will be whether Cleipnir has the sufficient support required to accomplish these goals.

%\section{Introduction}
%Introduction Template
%1. Context/Motivation
%2. Problem
%	-Why this is a hard/open problem?
%	-State-of-the-Art
%3. Key idea/insight
%	-Solution overview/some detail (bigger picture)
%4. Summary of research
%	-Details of contribution
%5. Evidence of successful solution (evaluation results)
%6. Summary of contributions
%7.  Paper outline
\input{sections/contributionsOutline}